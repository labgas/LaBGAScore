%% LaBGAScore_firstlevel_s2_fit_model.m
%
% This script does everything to fit and diagnose first level models,
% more specifically
%
% 1. checking dependencies, cloning CANlab Github repos if not yet present,
%   and adding all necessary (sub)folders to Matlab path if needed
%
% 2. creating the first level directory structure
%   NOTE: if you are using datalad (LaBGAS default), create the firstlevel
%   directory (without subdirectories) first using datalad commands from
%   your Linux terminal
%
% 3. reorganize derivdirs and their content for each subject, with
%   run-specific subdirs
%
% 4. extract noise regressors from fMRIprep output or create them using
%   CANlab functions (option specified in previous script) and save them in
%   the correct format to the run-specific directories for each subject
%   NOTE: by default we use the following noise regressors
%       a) global CSF signal
%       b) 24 head motion parameters (six directions, derivatives, and squared
%           values)
%       c) dummy spike regressors
%
% 5. extract onsets, durations, and (if applicable) parametric modulators
%   from events.tsv files created by LaBGAScore_prep_s1_write_events.tsv, and
%   save them in the correct format to the run-specific directories for each
%   subject
%
% 6. define and estimate first level model and save the spm batches
%   NOTE: CANlab functions called by this script in this step
%       a) https://github.com/canlab/CanlabCore/blob/master/CanlabCore/GLM_Batch_tools/canlab_glm_subject_levels.m
%       b) https://github.com/canlab/CanlabCore/blob/master/CanlabCore/GLM_Batch_tools/canlab_glm_subject_levels_run1subject.m
%       c) https://github.com/canlab/CanlabPrivate/blob/master/spmUtility/canlab_spm_contrast_job_luka.m
%
% 7. run diagnostics on first level model and publish the output by calling
%   the subsequent LaBGAScore_firstlevel_s3_diagnose_model script
%   NOTE: CANlab function called by this script
%       https://github.com/canlab/CanlabCore/blob/master/CanlabCore/diagnostics/scn_spm_design_check.m
% 
%
% USAGE
%
% LaBGAS_firstlevel_s1_options_dsgn_struct.m should always be run prior to
% this script; this script will check whether this is the case
% Script is generic, i.e. it should not need any study-specific
% modifcations
%
% 
% DEPENDENCIES
%
% 1. spm12 on Matlab path, with /canonical, /config, /matlabbatch, and
%   /toolbox subdirectories
% 2. CANlabCore & CANlabPrivate Github repos cloned and on Matlab path
%   https://github.com/canlab/CanlabCore
%   https://github.com/canlab/CanlabPrivate 
%   NOTE: dependencies are checked and cloned/added by the script if needed
%
%
% INPUTS 
% 
% 1. BIDS compliant dataset organized according to LaBGAS convention,
%   preprocessed using fmriprep,
%   and smoothed using LaBGAScore_prep_s2_smooth or another method
% 2. DSGN structure & options defined in LaBGAScore_firstlevel_s1_options_dsgn_structure
% 3. confound_timeseries.tsv files generated by fmriprep 
%   (if spike_def option == 'fmriprep')
% 4. events.tsv files generated by LaBGAScore_prep_s1_write_events_tsv or another method
%
%
% OUTPUTS
%
% First level directories for each subject for the model specified in DSGN, including
% 1. DSGN.mat file
% 2. SPM.mat file
% 3. beta_, con_, and spm_T images
% 4. SPM batches
%   a) specify and estimate model
%   b) specify contrasts
% 5. diagnostics subdirectory with html report
%
%
%__________________________________________________________________________
%
% authors: Lukas Van Oudenhove
% date:   March, 2022
%
%__________________________________________________________________________
% @(#)% LaBGAScore_firstlevel_s2_fit_model.m         v1.0        
% last modified: 2022/03/16


%% MAKE SURE DEPENDENCIES ARE ON MATLAB PATH, AND PREVIOUS SCRIPT IS RUN

% check whether LaBGAScore_firstlevel_s1_options_dsgn_struct has been run

if ~exist('DSGN','var')
    error('\nDSGN structure variable not found in Matlab workspace, please run LaBGAScore_firstlevel_s1_options_dsgn_struct before proceeding')
else
    cd(rootdir);
end

% check whether spm subdirs are on path, add if needed

spmcanonicaldir = fullfile(spmrootdir,'canonical');
    if sum(contains(matlabpath,spmcanonicaldir)) == 0
        addpath(spmcanonicaldir,'-end');
        warning('\nadding %s to end of Matlab path',spmcanonicaldir)
    end
spmconfigdir = fullfile(spmrootdir,'config');
    if sum(contains(matlabpath,spmconfigdir)) == 0
        addpath(spmconfigdir,'-end');
        warning('\nadding %s to end of Matlab path',spmconfigdir)
    end
spmmatlabbatchdir = fullfile(spmrootdir,'matlabbatch');
    if sum(contains(matlabpath,spmmatlabbatchdir)) == 0
        addpath(spmmatlabbatchdir,'-end');
        warning('\nadding %s to end of Matlab path',spmmatlabbatchdir)
    end
spmtoolboxdir = fullfile(spmrootdir,'toolbox');
    if sum(contains(matlabpath,spmtoolboxdir)) == 0
        addpath(spmtoolboxdir,'-end');
        warning('\nadding %s to end of Matlab path',spmtoolboxdir)
    end
    
% check whether CANlab Github repos are cloned and on Matlab path, clone and/or add if needed

  % CANLABCORE
    canlabcoredir = fullfile(githubrootdir,'CanlabCore');
        if ~isfolder(canlabcoredir) % canlabcore not yet cloned
          canlabcoreurl = "https://github.com/canlab/CanlabCore.git";
          canlabcoreclonecmd = ['git clone ' canlabcoreurl];
          cd(githubrootdir);
          [status,cmdout] = system(canlabcoreclonecmd);
          disp(cmdout);
              if status == -0
                  addpath(genpath(canlabcoredir,'-end'));
                  warning('\ngit succesfully cloned %s to %s and added repo to Matlab path',canlabcoreurl, canlabcoredir)
              else
                  error('\ncloning %s into %s failed, please try %s in linux terminal before proceeding, or use Gitkraken',canlabcoreurl,canlabcoredir,canlabcoreclonecmd)
              end
          cd(rootdir);
          clear status cmdout
        elseif ~exist('fmri_data.m','file') % canlabcore cloned but not yet on Matlab path
            addpath(genpath(canlabcoredir,'-end'));
        end
        
  % CANLABPRIVATE
    canlabprivdir = fullfile(githubrootdir,'CanlabPrivate');
        if ~isfolder(canlabprivdir) % canlabprivate not yet cloned
          canlabprivurl = "https://github.com/canlab/CanlabPrivate.git";
          canlabprivclonecmd = ['git clone ' canlabprivurl];
          cd(githubrootdir);
          [status,cmdout] = system(canlabprivclonecmd);
          disp(cmdout);
              if status == -0
                  addpath(genpath(canlabprivdir,'-end'));
                  warning('\ngit succesfully cloned %s to %s and added repo to Matlab path',canlabprivurl, canlabprivdir)
              else
                  error('\ncloning %s into %s failed, please try %s in linux terminal before proceeding, or use Gitkraken',canlabprivurl,canlabprivdir,canlabprivclonecmd)
              end
          cd(rootdir);
          clear status cmdout
        elseif ~exist('power_calc.m','file') % canlabprivate cloned but not yet on Matlab path
            addpath(genpath(canlabprivdir,'-end'));
        end

    
%% CREATE DIRECTORY STRUCTURE

% define mkdir as an anonymous function that can be applied to cell arrays
% to crease directory structure

sm=@(x)mkdir(x);

% create first level directory

firstleveldir = fullfile(rootdir,'firstlevel');
    if ~exist(firstleveldir,'dir')
        mkdir(firstleveldir);
    end

% create firstmodeldir

firstmodeldir = DSGN.modeldir;
    if ~exist(firstmodeldir,'dir')
        mkdir(firstmodeldir);
    end

% write subjectdirs in firstmodeldir

    if ~contains(ls(firstmodeldir),'sub-') % checks whether there are already subject dirs in firstmodeldir
        cd (firstmodeldir);
        cellfun(sm,derivsubjs);
    end
    
cd(rootdir);

% create list of subjectdirs in firstmodel dir

firstlist = dir(fullfile(firstmodeldir,'sub-*'));
firstsubjs = cellstr(char(firstlist(:).name));

    for firstsub = 1:size(firstsubjs,1)
        firstsubjdirs{firstsub,1} = fullfile(firstlist(firstsub).folder,firstlist(firstsub).name);
    end


%% LOOP OVER SUBJECTS
%--------------------------------------------------------------------------

for sub=1:size(derivsubjs,1)
    
    %% DEFINE SUBJECT LEVEL DIRS & FILENAMES
    
    subjderivdir = fullfile(derivsubjdirs{sub},'func');
    subjBIDSdir = fullfile(BIDSsubjdirs{sub},'func');
    subjfirstdir = firstsubjdirs{sub};
    
    BIDSimgs = dir(fullfile(subjBIDSdir,'*bold.nii.gz'));
    BIDSimgs = {BIDSimgs(:).name}';
    BIDSidx = ~contains(BIDSimgs,'rest'); % omit resting state scan if it exists
    BIDSimgs = {BIDSimgs{BIDSidx}}';
    
    derivimgs = dir(fullfile(subjderivdir,'s6-*.nii.gz'));
    derivimgs = {derivimgs(:).name}';
    derividx = ~contains(derivimgs,'rest'); % omit resting state scan if it exists
    derivimgs = {derivimgs{derividx}}';
    
    fmriprep_noisefiles = dir(fullfile(subjderivdir,'*desc-confounds_timeseries.tsv'));
    fmriprep_noisefiles = {fmriprep_noisefiles(:).name}';
    noiseidx = ~contains(fmriprep_noisefiles,'rest'); % omit resting state scan if it exists
    fmriprep_noisefiles = {fmriprep_noisefiles{noiseidx}}';
    
    % read events.tsv files with onsets, durations, and trial type
    eventsfiles = dir(fullfile(subjBIDSdir,'*events.tsv'));
    eventsfiles = {eventsfiles(:).name}';
    
    for runname = 1:size(fmriprep_noisefiles,1)
        subjrunnames{runname} = strsplit(fmriprep_noisefiles{runname},'_desc');
        subjrunnames{runname} = subjrunnames{runname}{1};
        subjrundirnames{runname} = subjrunnames{runname}(end-4:end);
    end
    subjrunnames = subjrunnames';
    subjrundirnames = subjrundirnames';
        
    % create rundirs in subjderivdir if needed
    if ~isfolder(fullfile(subjderivdir,rundirnames{1}))
        cd(subjderivdir);
        cellfun(sm,rundirnames);
    end
    
    cd(rootdir);
    
    % sanity check #1: number of images & noise/event files
    if ~isequal(size(BIDSimgs,1),size(derivimgs,1),size(fmriprep_noisefiles,1),size(eventsfiles,1)) 
        error('\nnumbers of raw images, preprocessed images, noise, and events files do not match for %s, please check BIDSimgs, derivimgs, fmriprep_noisefiles, and eventsfiles variables before proceeding',derivsubjs{sub});
    else
        warning('\nnumbers of raw images, preprocessed images, noise, and events files match for %s, continuing',derivsubjs{sub});
    end

    %% LOOP OVER RUNS: CREATE NOISE REGRESSORS, ONSETS, DURATIONS, AND PARAMETRIC MODULATORS
    
    for run=1:size(fmriprep_noisefiles,1)
        
        % DEFINE SUBDIR FOR THIS RUN
        rundir = fullfile(subjderivdir,subjrundirnames{run});
        
        % MOVE FMRIPREP NOISEFILE AND SMOOTHED IMAGE INTO RUNDIR IF
            if ~contains(ls(rundir),fmriprep_noisefiles{run})
                copyfile(fullfile(subjderivdir,fmriprep_noisefiles{run}),fullfile(rundir,fmriprep_noisefiles{run}));
            end

            if ~contains(ls(rundir),derivimgs{run})
                copyfile(fullfile(subjderivdir,derivimgs{run}),fullfile(rundir,derivimgs{run}));
                gunzip(fullfile(rundir,derivimgs{run}));
                delete(fullfile(rundir,derivimgs{run}));
            end

        % CONFOUND REGRESSOR FILES
        
        % load confound regressor file generated by fMRIprep into Matlab table
        % variable
        Rfull = readtable(fullfile(rundir,fmriprep_noisefiles{run}),'TreatAsEmpty','n/a','FileType', 'text', 'Delimiter', 'tab');

        % replace NaNs in first row with Os
        wh_replace = ismissing(Rfull(1,:));
            if any(wh_replace)
                Rfull{1, wh_replace} = zeros(1, sum(wh_replace)); % make array of zeros of the right size
            end

        % calculate and extract confound regressors
            if strcmpi(spike_def,'fMRIprep')==1 % switch would probably make more sense in this case, but this works too!

                % define regressors in fMRIprep output
                regs=Rfull.Properties.VariableNames;
                spike_cols = contains(regs,'motion_outlier');
                Rspikes=Rfull(:,spike_cols);
                Rspikes.spikes=sum(Rspikes{:,1:end},2);
                volume_idx = [1:height(Rfull)]; 
                spikes = volume_idx(Rspikes.spikes==1);

                % flag user-specified number of volumes after each spike
                % Motion can create artifacts lasting longer than the single image we
                % usually account for using spike id scripts. we're also going to flag the
                % following TRs, the number of which is defined by the user. If
                % 'spike_additional_vols' remains unspecified, everything will proceed as
                % it did before, meaning spikes will be identified and flagged in the
                % creation of nuisance regressors without considering the following TRs
                % Add them if user requested, for both nuisance_covs and dvars_spikes_regs
                    if exist('spike_additional_vols')
                        additional_spikes_regs = zeros(height(Rfull),size(spikes,2)*spike_additional_vols);
                            % This loop will create a separate column with ones in each row (TR) 
                            % we would like to consider a nuisance regressor
                            for i = 1:size(spikes,2) 
                                additional_spikes_regs(spikes(i)+1 : spikes(i)+spike_additional_vols,(i*spike_additional_vols-(spike_additional_vols-1)):(i*spike_additional_vols)) = eye(spike_additional_vols);
                            end
                        % if any spikes went beyond the end, trim it down
                        additional_spikes_regs = additional_spikes_regs(1:height(Rfull),:);
                        % add the additional spikes to the larger matrix
                        Rfull = [Rfull array2table(additional_spikes_regs)];
                    end

                % remove redundant spike regressors
                regs = Rfull.Properties.VariableNames;
                spike_cols = contains(regs,'motion_outlier');
                additional_spike_cols = contains(regs,'additional_spikes'); 
                [duplicate_rows, ~] = find(sum(Rfull{:, spike_cols | additional_spike_cols}, 2)>1);
                    for i = 1:length(duplicate_rows) % This loop sets duplicate values to zero; drops them later (to keep indices the same during the loop)
                        [~,curr_cols] = find(Rfull{duplicate_rows(i),:}==1);
                        Rfull{duplicate_rows(i), curr_cols(2:end)} = 0;
                    end
                Rfull = Rfull(1:height(Rfull), any(table2array(Rfull)));

            elseif strcmpi(spike_def,'CANlab')==1

                % unzip & define raw image file
                gunzip(BIDSimgs{run}); % raw images are needed when spike_def = CANlab, which calls a function that is incompatible with .nii.gz, hence we unzip
                uBIDSimg = dir(fullfile(subjBIDSdir,'*bold.nii'));
                uBIDSimg = {uBIDSimg(:).name}';

                % add in canlab spike detection (Mahalanobis distance)
                [g, mahal_spikes, gtrim, mahal_spikes_regs, snr] = scn_session_spike_id(fullfile(subjBIDSdir,uBIDSimg), 'doplot', 0); % CANlab function needs to be on your Matlab path
                delete('*.img'); % delete implicit mask .hdr/.img files generated by the CANlab function on the line above, since we don't need/use them
                delete('*.hdr');
                delete(uBIDSimg); % delete unzipped image since we don't need it anymore and it eats up space
                mahal_spikes_regs(:,1) = []; %drop gtrim which is the global signal
                Rfull(:,contains(Rfull.Properties.VariableNames,'motion_outlier'))=[]; % drop fmriprep motion outliers since we do not use them when spike_def = CANlab, and they cause redundancies
                Rfull = [Rfull array2table(mahal_spikes_regs)];

                % add in dvars spike regressors that are non-redundant with mahal spikes
                dvarsZ = [0; zscore(Rfull.dvars(2:end))]; % first element of dvars always = 0, drop it from zscoring and set it to Z=0
                dvars_spikes = find(dvarsZ > dvars_threshold);
                same = ismember(dvars_spikes,mahal_spikes);
                dvars_spikes(same) = []; % drop the redundant ones
                dvars_spikes_regs = zeros(height(Rfull),size(dvars_spikes,1));
                    for i=1:size(dvars_spikes,1)
                        dvars_spikes_regs(dvars_spikes(i),i) = 1;
                    end
                Rfull = [Rfull array2table(dvars_spikes_regs)];

                % flag user-specified number of volumes after each spike
                % Motion can create artifacts lasting longer than the single image we
                % usually account for using spike id scripts. we're also going to flag the
                % following TRs, the number of which is defined by the user. If
                % 'spike_additional_vols' remains unspecified, everything will proceed as
                % it did before, meaning spikes will be identified and flagged in the
                % creation of nuisance regressors without considering the following TRs
                % Add them if user requested, for both nuisance_covs and dvars_spikes_regs
                    if exist('spike_additional_vols')
                        % concatenate generated spike and DVARS regs. We
                        % would like to flag subsequent TR's with respect to both of these
                        % measures.
                        spikes = [mahal_spikes;dvars_spikes];
                        additional_spikes_regs = zeros(size(mahal_spikes_regs,1),size(spikes,1)*spike_additional_vols);
                            % This loop will create a separate column with ones in each row (TR) 
                            % we would like to consider a nuisance regressor
                            % Performs this function for spikes and DVARS. 
                            for i = 1:size(spikes,1) 
                                additional_spikes_regs(spikes(i)+1 : spikes(i)+spike_additional_vols,(i*spike_additional_vols-(spike_additional_vols-1)):(i*spike_additional_vols)) = eye(spike_additional_vols);
                            end
                        % if any spikes went beyond the end, trim it down
                        additional_spikes_regs = additional_spikes_regs(1:height(Rfull),:);
                        % add the additional spikes to the larger matrix
                        Rfull = [Rfull array2table(additional_spikes_regs)];
                    end

                % remove redundant spike regressors
                regs = Rfull.Properties.VariableNames;
                spike_cols = contains(regs,'mahal_spikes'); 
                dvars_cols = contains(regs,'dvars_spikes'); 
                additional_spike_cols = contains(regs,'additional_spikes'); 

                [duplicate_rows, ~] = find(sum(Rfull{:, spike_cols | dvars_cols | additional_spike_cols}, 2)>1);
                    % set duplicate values to zero; drops them later (to keep indices the same during the loop)
                    for i = 1:size(duplicate_rows,1) 
                        [~,curr_cols] = find(Rfull{duplicate_rows(i),:}==1);
                        Rfull{duplicate_rows(i), curr_cols(2:end)} = 0;
                    end
                Rfull = Rfull(1:size(mahal_spikes_regs,1), any(table2array(Rfull)));
            else
                error('\ninvalid spike_def option')
            end

        % Select confound and spike regressors to return for use in GLM 
        regs = Rfull.Properties.VariableNames;
        motion_cols = contains(regs,'rot') | contains(regs,'trans');
        spike_cols = contains(regs,'mahal_spikes') | contains(regs,'motion_outlier'); 
        dvars_cols = contains(regs,'dvars_spikes'); 
        additional_spike_cols = contains(regs,'additional_spikes'); 
        R = Rfull(:,motion_cols | spike_cols | dvars_cols | additional_spike_cols);
        R.csf = Rfull.csf;
        Rspikes=Rfull(:,spike_cols | dvars_cols | additional_spike_cols);
        Rspikes.spikes=sum(Rspikes{:,1:end},2);
        volume_idx = [1:height(Rfull)]; 
        spikes = volume_idx(Rspikes.spikes==1)';

        % compute and output how many spikes total
        n_spike_regs = sum(dvars_cols | spike_cols | additional_spike_cols);
        n_spike_regs_percent = n_spike_regs / height(Rfull);

        % print warning if #volumes identified as spikes exceeds
        % user-defined threshold
            if n_spike_regs_percent > spikes_percent_threshold
                warning('\nnumber of volumes identified as spikes exceeds threshold %s in %s',spikes_percent_threshold,subjrunnames{run})
            end

        % save confound regressors as matrix named R for use in
        % SPM/CANlab GLM model tools
        R=table2array(R);

        % define and create subdir for model
        runmodeldir = fullfile(rundir,DSGN.modelingfilesdir);
            if ~exist(runmodeldir,'dir')
                mkdir(runmodeldir);
            end

        % write confound regressors
        filename_noise_regs = fullfile(runmodeldir,DSGN.multireg);
        save(filename_noise_regs,'R');

        clear R* filename_events

        % EVENTS FILES
        % read events.tsv files
        O = readtable(fullfile(subjBIDSdir,eventsfiles{run}),'FileType', 'text', 'Delimiter', 'tab');
        O.trial_type = categorical(O.trial_type);
        O.Properties.VariableNames(categorical(O.Properties.VariableNames) == pmod_name) = {'pmod'};
        
        % omit trials that coincide with spikes if that option is chosen
            if strcmpi(omit_spike_trials,'yes')==1
                same=ismember(O.onset,spikes); % identify trials for which onset coincides with spike
                O(same,:)=[]; % get rid of trials coinciding with spikes
            elseif strcmpi(omit_spike_trials,'no')==1
            else
                error('\ninvalid omit_spike_trials option')
            end

        % sanity check #2: conditions
        cat_conds = reordercats(categorical(DSGN.conditions{run}));
        cat_conds = categories(cat_conds);
        cat_trial_type = cellstr(unique(O.trial_type));

            if ~isequal(cat_trial_type,cat_conds)
                error('\nconditions in DSGN structure do not match conditions in %s, please check before proceeding',fmriprep_noisefiles{run})
            else 
                warning('\nconditions in DSGN structure match conditions in %s, continuing',fmriprep_noisefiles{run})
            end

        % initialize structures for conditions
            for cond = 1:size(DSGN.conditions{1},2)
                cond_struct{cond} = struct('name',{DSGN.conditions{run}(cond)}, ...
                    'onset',{{[]}}, ...
                    'duration',{{[]}});
            end

            clear cond

        % fill structures with onsets and durations
            for trial = 1:size(O.trial_type,1)
                cond = 1;
                while cond < size(DSGN.conditions{run},2) + 1
                    switch O.trial_type(trial)
                        case DSGN.conditions{run}{cond}
                                cond_struct{cond}.onset{1} = [cond_struct{cond}.onset{1},O.onset(trial)];
                                cond_struct{cond}.duration{1} = [cond_struct{cond}.duration{1},O.duration(trial)];
                    end
                cond = cond + 1;
                end
                continue
            end

            clear cond

        % add pmods to structures for conditions of interest if specified in DSGN
            if isfield(DSGN,'pmods')
                for pmod = 1:size(DSGN.pmods{run},2)
                    cond_struct{pmod}.pmod = struct('name',{DSGN.pmods{run}(pmod)}, ...
                        'param',{{[]}}, ...
                        'poly',{{pmod_polynom}});
                    if pmod_ortho_off
                        cond_struct{pmod}.orth = {[0]};
                    end
                end
                
                clear pmod
                
                for trial = 1:size(O.trial_type,1)
                    pmod = 1;
                    while pmod < size(DSGN.pmods{run},2) + 1
                        switch O.trial_type(trial)
                            case DSGN.conditions{run}{pmod}
                               cond_struct{pmod}.pmod.param{1} = [cond_struct{pmod}.pmod.param{1},O.pmod(trial)];
                        end
                    pmod = pmod + 1;
                    end
                    continue
                end
                
                clear pmod
                
            end


        % sanity check #3: design info
        nii = dir(fullfile(rundir,'*.nii')).name;
        nii_hdr = read_hdr(fullfile(rundir,nii)); % reads Nifti header of smoothed image into a structure

            for cond = 1:size(DSGN.conditions{1},2)
                DesignTiming(1,cond) = (max(cond_struct{cond}.onset{1}) + cond_struct{cond}.duration{1}(1,end));
            end

            clear cond

        maxDesignTiming = max(DesignTiming);
        boldDuration = nii_hdr.tdim*DSGN.tr;

            if boldDuration < maxDesignTiming
                error('\nEnd of last condition (%s sec) exceeds BOLD duration (%s sec) in %s, please check before proceeding', num2str(maxDesignTiming), num2str(boldDuration), subjrunnames{run})
            else
                warning('\nEnd of last condition (%s sec) does not exceed BOLD duration (%s sec) in %s, continuing', num2str(maxDesignTiming), num2str(boldDuration), subjrunnames{run})
            end

        % save events file as .mat file
            for cond = 1:size(DSGN.conditions{1},2)
                struct = cond_struct{cond};
                save(fullfile(runmodeldir,char(cond_struct{cond}.name)),'-struct','struct');
                clear struct
            end
        
    end % for loop runs
    
    %% FIT FIRST LEVEL MODEL
    
    fprintf('\nRunning on subject directory %s\n',DSGN.subjects{sub});
    canlab_glm_subject_levels(DSGN,'subjects',DSGN.subjects(sub),'overwrite','nolinks','noreview');
    
    
    %% DIAGNOSE FIRST LEVEL MODEL
    
    subjfirstdiagnosedir = fullfile(subjfirstdir,'diagnostics');
        if ~exist(subjfirstdiagnosedir,'dir')
            mkdir(subjfirstdiagnosedir);
        end
        
    cd(subjfirstdiagnosedir);
        
    diagnose_struct = struct('useNewFigure',false,'maxHeight',800,'maxWidth',1600,...
        'format','html','outputDir',subjfirstdiagnosedir,...
        'showCode',true);
    
    publish('LaBGAScore_first_s2_diagnose_firstlvl.m',diagnose_struct)
    delete('High_pass_filter_analysis.png','Variance_Inflation.png','LaBGAScore_first_s2_diagnose_firstlvl.png'); % getting rid of some redundant output images due to the use of publish()
    
    cd(rootdir);
    
    
end % for loop subjects 